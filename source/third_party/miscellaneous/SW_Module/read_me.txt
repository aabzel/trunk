Стандарты разработки программных модулей (НПП Итэлма, отдел разработки базового ПО)
Введение
В этом документе представлены правила разработки программных модулей базового ПО.

Разработчик при написании своего модуля должен безукоризненно следовать им.

Аббревиатуры
API - Application Programming Interface,
EHAL - Embedded Hardware Abstraction Layer,
IRQ - Interrupt Request,
MAL - Microcontroller Abstraction Layer,
ПМ - Программный Модуль,
ПО - Программное Обеспечение.

 

Основные правила
[REQ_SW_2500] Используется язык программирования С (С99).

[REQ_SW_2501] Используется стандарт кодирования MISRA-C (2004) избранные правила.

[REQ_SW_2502] Использование кода сторонних библиотек запрещено.

Комментарий к
REQ_SW_2500: допускаются вставки ассемблерного кода.
REQ_SW_2502: это правило означает замкнутость архитектуры EHAL. Если Вы хотите заимствовать сторонний код, то он должен быть

a. полностью понят и тщательно проверен,

b. приведен к внутреннему codestyle,

c. быть архитектурно-совместимым.

 

Структура программного модуля
Состав программного модуля
Программный модуль (далее ПМ) должен состоять из:

[REQ_CODE_0002] c-файла имплементации,

[REQ_CODE_0003] h-файла интерфейса,

[REQ_CODE_0004] h-файла шаблона конфигурации формата .h.tmpl, если ПМ нуждается в конфигурации

[REQ_CODE_0005] h, c-файлов обработчиков прерываний, если ПМ является MAL драйвером и работает с прерываниями

[REQ_CODE_0006] других исходных файлов при необходимости

Примечание:

Файл имплементации это с-файл, в котором определяются API-функции, объявленные в h-файле интерфейса.
Создание файла конфигурации .h.tmpl определяется необходимостью ПМ в статическом конфигурировании. Если такой необходимости нет, то файл конфигурации создавать не нужно.
Но большинство модулей EHAL обеспечены таким файлом. При проектировании ПМ нужно стараться избегать конфигурационных констант, в идеале полностью отказаться от них.
В файлах обработчиков прерываний объявляются и определяются соответственно функции обработки прерываний. Такие файлы создаются для модулей, которые относятся к уровню MAL архитектуры EHAL (так называемые драйвера MAL).
Функции, определяемые в данных файлах, впоследствие будут установлены на вектора прерываний с помощью отдельного программного модуля (IRQ драйвера). Имена таких файлов оканчиваются на "_irq.c (.h)". Например, flash_drv_irq.c (flash_drv_irq.h).
Создание других вспомогательных файлов (.h, .c) определяется намерением улучшить читаемость и восприятие ПМ.
Например, можно создать файл с окончанием "_types.h", чтобы перенести в него часть специфических для данного модуля констант и типов из основного файла имплементации для концентрации внимания лишь на реализации функций.
Расположение файлов и каталогов ПМ
В данном репозитории представлена типичная структура репозитория программного модуля:

[REQ_CODE_0007] если программный модуль имеет разные имплементации под один интерфейс, то файл интерфейса должен храниться в отдельном репозитории (называемом репозиторием интерфейса) и подключаться в репозиторий имплементации в качестве git-сабмодуля в директорию src/interface.
Если программный модуль имеет одну единственную имплементацию под интерфейс, то файл интерфейса должен храниться просто в директории src/.

[REQ_CODE_0008] остальные файлы ПМ должны храниться в каталоге src/.

[REQ_DOC_0001] документация ПМ должна храниться в каталоге doc/.

Примечание: в данном репозитории файл module_cfg.h назван без расширения ".tmpl" исключительно для подсветки синтаксиса в Bitbucket'е. В реальном программном модуле необходимо именовать этот файл с расширением ".tmpl".

Также в директории src/ директория interface/ не является сабмодулем. В реальном репозитории это зависит от количества имплементаций программного модуля под один интерфейс. Примером разных имплементаций может быть драйвер под разные платформы. Как правило над наличием сабмодуля в репозитории имплементации заранее заботится администратор проекта в Bitbucket. Настройки сабмодуля (если он имеется) изначально находятся в ветке dev. Программисту модуля остается лишь выполнить специальную команду git, чтобы подтянуть сабмодуль. Ни в коем случае не меняйте подтянутый сабмодуль. Если возникла такая необходимость, то это нужно сделать через Pull Request в репозитории сабмодуля.

Именование файлов
Исходные файлы должны именоваться:

[REQ_CODE_0009] на английском языке
[REQ_CODE_0010] в нижнем регистре
[REQ_CODE_0011] в стиле snake_case
[REQ_CODE_0012] шаблон конфигурации ПМ должен иметь расширение ".h.tmpl".
Документ

[REQ_DOC_0002] руководство программиста должен именоваться в соответствии с именем шаблона.
Включение файлов
Должны быть соблюдены следующие правила включения файлов:

[REQ_CODE_0013] с-файл имплементации должен включать в себя h-файл интерфейса
[REQ_CODE_0014] h-файл интерфейса должен включать в себя h-файл конфигурации
[REQ_CODE_0015] h-файл конфигурации не должен включать в себя никакие файлы
[REQ_CODE_0016] h, c-файлы не должны дублировать неявное включение одного и того же h-файла
[REQ_CODE_0017] с-файл не должен включаться ни в какие другие файлы
 

Стандарт кодирования
Правила оформления с-файла
Должен быть соблюден следующий порядок секций в с-файле (см. шаблон module.c):

[REQ_CODE_0101] заголовок с-файла
[REQ_CODE_0102] подключаемые заголовочные h-файлы
[REQ_CODE_0103] верификация констант кофигурации
[REQ_CODE_0104] определения глобальных переменных
[REQ_CODE_0105] объявления локальных для файла типов данных
[REQ_CODE_0106] определения локальных для файла констант
[REQ_CODE_0107] определения локальных для файла переменных
[REQ_CODE_0108] объявления локальных для файла функций
[REQ_CODE_0109] определения глобальных функций
[REQ_CODE_0110] определения локальных для файла функций
В секции "Project Includes":

[REQ_CODE_0111] включение заголовочного h-файла интерфейса должно идти первым
Правила оформления h-файла интерфейса
Должен быть соблюден следующий порядок секций в h-файле интерфейса (см. шаблон module.h):

[REQ_CODE_0201] заголовок h-файла
[REQ_CODE_0202] подключаемые заголовочные h-файлы
[REQ_CODE_0203] объявления глобальных типов данных
[REQ_CODE_0204] определения глобальных констант
[REQ_CODE_0205] объявления глобальных переменных
[REQ_CODE_0206] объявления глобальных функций
Правила оформления h-файла конфигурации
Должен быть соблюден следующий порядок секций в конфигурационном h-файле (см. шаблон module_cfg.h):

[REQ_CODE_0301] заголовок h-файла
[REQ_CODE_0302] определения глобальных констант
Доп. требования:

[REQ_CODE_0303] в конфигурационном h-файле не должно быть препроцессорных директив условной компиляции (исключение: #ifndef ... #endif для защиты от повторного включения)

[REQ_CODE_0304] определение неконфигурируемых (фиксированных) констант запрещено

[REQ_CODE_0305] по умолчанию все значения констант должны быть по возможности минимальными: FALSE, OFF, 0U, LOW, ... и т.п.

[REQ_CODE_0306] каждая конфигурационная константа должна иметь комментарий с "Valid values", в котором описано множество возможных значений данной константы

 

Правила кодирования
[REQ_CODE_0400] вместо базовых типов данных (char, int, float и т.п.) должны быть использованы их переопределения из файла platform.h для соответствующего процессора

[REQ_CODE_0401] вместо компиляторных расширений (#pragma, interrupt, inline и т.п.) должны быть использованы их переопределения из файла compiler.h для соответствующего компилятора

[REQ_CODE_0402] идентификаторы должны быть объявлены в одном и только в одном файле

[REQ_CODE_0403] идентификаторы должны быть определены в одном и только в одном файле

[REQ_CODE_0404] неиспользуемые идентификаторы не должны быть объявлены или определены в коде, за исключением тех, которые являются API модуля

[REQ_CODE_0405] в одной строке должно быть не более одного определения

[REQ_CODE_0406] в одной строке должно быть не более одного объявления

[REQ_CODE_0407] в h-файле должны быть только объявления идентификаторов, все определения – в с-файле (исключение – inline-функции и глобальные константы)

[REQ_CODE_0408] для всех объявлений глобальных функций и переменных в h-файле обязательно ключевое слово extern

[REQ_CODE_0409] определение функций с ключевым словом extern запрещено

[REQ_CODE_0410] для всех объявлений и определений локальных функций обязательно ключевое слово static

[REQ_CODE_0411] для всех определений глобальных переменных с областью видимости, ограниченной файлом, обязательно ключевое слово static

[REQ_CODE_0412] порядок объявления функций должен совпадать с порядком определения функций

[REQ_CODE_0413] объявления функций должны в точности соответствовать их определениям

[REQ_CODE_0414] все параметры функций должны быть перечислены "в столбик"

[REQ_CODE_0415] все параметры функций должны быть по возможности использованы. Неиспользованные параметры (н-р, случай унаследованного интерфейса) должны быть вызваны в начале тела функции с приведением типа

[REQ_CODE_0416] функции без параметров должны содержать в скобках void

[REQ_CODE_0417] ко всем параметрам функций должен быть по возможности применен спецификатор const

[REQ_CODE_0418] все локальные переменные функций должны быть проинициализированы до первого использования

[REQ_CODE_0419] не должно быть "холостых" инициализаций локальных переменных. Пример

[REQ_CODE_0420] если ПМ содержит функции инициализации (и деинициализации), то статус инициализации должен проверяться во всех API-функциях ПМ

[REQ_CODE_0421] при вызове non-void функции, ее возвращаемое значение должно проверяться

[REQ_CODE_0422] все параметры макросов должны быть заключены в скобки

[REQ_CODE_0423] в сложных выражениях везде должны стоять скобки

[REQ_CODE_0424] тело конструкций if, else if, switch, for, while, do..while должно быть заключено в фигурные скобки

[REQ_CODE_0425] в условном выражении не должно быть "одиноких" операндов: каждый операнд должен по возможности сравниваться c другими. Исключение: операнды с говорящим названием. Пример

[REQ_CODE_0426] побитовые операторы &, | не должны быть использованы вместо логических &&, || и наоборот

[REQ_CODE_0427] при сравнении константы и переменной с помощью знаков == или !=, константа должна стоять слева, а переменная справа от знака сравнения

[REQ_CODE_0428] в конце оператора выбора switch должен быть default case

[REQ_CODE_0429] все конструкции else if должны иметь завершающий else

[REQ_CODE_0430] ко всем беззнаковым константам должен быть применен суффикс U (UL для типа long)

[REQ_CODE_0431] в исходном коде не должно быть "магических чисел": все символьные константы должны иметь осмысленные имена

[REQ_CODE_0432] переопределение констант, типов, макросов из файлов general.h, general_types.h, general_macros.h запрещено. Пример

[REQ_CODE_0433] использование констант ON/OFF вместо TRUE/FALSE должно быть логически обосновано. Пример

 

Правила использования комментариев
[REQ_CODE_0500] все объявления и определения должны быть прокомментированы

[REQ_CODE_0501] если блок кода не помещается на один экран монитора, то после закрывающей блок скобкой или #endif должен быть комментарий, поясняющий, какой блок кода закончился

[REQ_CODE_0502] завершающая тело функции скобка должна быть прокомментирована (см. шаблон)

[REQ_CODE_0503] предпоследняя строка исходного файла должна содержать комментарий "end of file" (см. шаблон)

[REQ_CODE_0504] "шапки" комментариев (к файлу, к функциям) не должны содержать пустых полей. Если поле пустое (то есть нечего добавить в это поле), то нужно писать в нем слово None. Также это касается случая, когда секция кода пустая (из тр. REQ_CODE_0102-REQ_CODE_0302).

[REQ_CODE_0505] закомментированный код запрещается

[REQ_CODE_0506] комментарии должны начинаться с //

[REQ_CODE_0507] комментарии должны начинаться с заглавной буквы, кроме их продолжений на новой строке и комментариев типа // end of ...

[REQ_CODE_0508] комментарии должны быть на английском языке

[REQ_CODE_0509] комментарии должны быть грамматически правильными

[REQ_CODE_0510] комментарии должны быть ясными и полными

[REQ_CODE_0511] комментарии должны правильно отражать суть

[REQ_CODE_0512] комментарии должны быть оформлены в соответствии с шаблоном (см. module.c, module.h module_cfg.h)

Правила форматирования
[REQ_CODE_0600] исходный текст должен быть ясным и четким: приветствуется выравнивание, единообразие, "умеренное" комментирование и т.п.

[REQ_CODE_0601] исходный текст должен содержать только ASCII-совместимые символы

[REQ_CODE_0602] исходный текст должен заканчиваться комментарием "end of file" (см. шаблон) и пустой строкой

[REQ_CODE_0603] исходный текст не должен содержать лишних пробелов, разрывов и пр. Он должен максимально соответствовать шаблону.

[REQ_CODE_0604] ширина строки не более 100 символов

[REQ_CODE_0605] табуляция должна быть заменена в настройках редактора 4-мя пробелами

[REQ_CODE_0606] перед началом каждой секции должно быть ровно три пустые строки

Правила использования пробелов в коде
Должны быть соблюдены следующие правила использования пробелов в коде:

Номер   Описание    Неправильно Правильно
[REQ_CODE_0607] После запятой   a,b,c,d a, b, c, d
[REQ_CODE_0608] После символа //    //DoSomething   // DoSomething
[REQ_CODE_0609] До и после операторов (присваивания, арифметических, логических)    a=(b+c)*d;  a = (b + c) * d;
[REQ_CODE_0610] После if (#if), for, while, switch  if(..., for(..., while(...  if (..., for (..., while (...
[REQ_CODE_0611] После } в typedef'ах    }DATA_TYPE; } DATA_TYPE;
[REQ_CODE_0612] Без пробела после названия функции  void Func (void)    void Func(void)
[REQ_CODE_0613] Без пробела после cкобок приведения типов   (U8) counter    (U8)counter
[REQ_CODE_0614] Без пробела между типом указателя и символом *  U8 * ptr; U8 *ptr;  U8* ptr;
[REQ_CODE_0615] Без пробела перед инкр./декрементом counter ++; counter++
[REQ_CODE_0616] Без пробела перед символом ;    U8 num ;    U8 num;
[REQ_CODE_0617] Без пробела перед символом : в case case WAKEUP :   case WAKEUP:
[REQ_CODE_0618] Без пробела до закрывающей и после открывающей скобок [, ], (, ), {, }  void Func( const U8 param );    void Func(const U8 param);
Правила именования идентификаторов
Имя идентификатора должно включать следующую информацию:

тип (тип данных, именованная константа, макрос, переменная, функция);

область видимости (локальная для функции, локальная для модуля, глобальная);

суть.

Информацию о типе и области видимости идентификатора формируют следующие элементы правил:

Элемент правила именования  Цель
имя модуля в начале имени   
определить программный модуль, к которому относится идентификатор
отличать локальные для функции переменные от глобальных переменных
разный регистр букв 
отличать типы от переменных
отличать функции от макросов
отличать переменные от функций
наличие/отсутствие разделителя (символ подчеркивания)   
выделить имя модуля из имени идентификатора
отличать типы от переменных
отличать функции от макросов
Сводная таблица правил именования идентификаторов
[REQ_CODE_0700]

Тип идентификатора  Область видимости   Формат имени идентификатора Описание    Пример имени идентификатора при определении
Типы данных     ИМЯМОДУЛЯ_ИМЯ_ТИПА  Имя дополняется префиксом с именем модуля, включает только прописные буквы, слова разделяются символом подчеркивания    typedef struct { } SPI_CONFIG;
Именованная константа       ИМЯМОДУЛЯ_ИМЯ_КОНСТАНТЫ     #define SPI_CHANNELS_TOTAL (2)
Макрос      ИМЯМОДУЛЯ_ИМЯ_МАКРОСА       #define SPI_CHECK_BUSY(state) (SPI_STAT_REG & SPI_BUSY_FLAG & (state))
Переменная  Локальная для функции   имяПеременной   Имя включает буквы обоих регистров, первое слово начинается со строчной буквы, все последующие – с прописной буквы, разделитель не используется U16 msgIdx;
Локальная для модуля    ИМЯМОДУЛЯ_имяПеременной Имя дополняется префиксом с именем модуля, включает буквы обоих регистров, первое слово начинается со строчной буквы, все последующие – с прописной буквы, разделитель используется только после имени модуля   static U16 SPI_bufOverflow;
Глобальная          U16 SPI_bufOverflowCnt;
Функция Локальная для модуля    ИМЯМОДУЛЯ_ИмяФункции()  Имя дополняется префиксом с именем модуля, включает буквы обоих регистров, все слова начинаются с прописной буквы, разделитель используется только после имени модуля   static SPI_STATUS SPI_GetStatus(void);
Глобальная          SPI_STATUS SPI_GetStatus(void);
Для параметров функций и макросов правила именования такие же, как для локальных переменных функций.

Имя модуля включает только прописные буквы.

Если в имени идентификатора используется аббревиатура, то все символы аббревиатуры должны быть с прописной буквы (например, ADC, а не Adc). Список общепринятых стандартных аббревиатур см. в Приложении 2. Следует отличать сокращение от аббревиатуры. Для сокращений действуют те же правила, что и для полного имени. Список общепринятых стандартных сокращений см. в Приложении 3.

Общий принцип именования: имя идентификатора должно четко отражать его сущность. При этом должен быть достигнут баланс между избыточной детализацией и излишней краткостью. Например, локальную для функции переменную, отражающую число принятых байт из канала UART, можно было бы назвать numberOfBytesReceivedFromTheUARTModule (избыточная детализация), или bytes (излишняя краткость). Оптимальное имя в данном случае: receivedBytesCnt.

Примеры
Смысл переменной    Адекватное имя  Неадекватные имена
Общее число сообщений   msgTotal    y2, messages, tmp5, number
Идентификатор устройства    deviceID    xx, ident, dId
Текущее напряжение  currentVoltage  temp, aaa, current, cv, voltage
 

Требования к тестированию ПМ
[REQ_PRJ_0001] Директория test/dev должна содержать тестовый проект разработчика

[REQ_PRJ_0002] Структура директорий и расположений файлов тестового проекта должна соответствовать шаблону test/dev

[REQ_PRJ_0003] Тестовый проект должен соответствовать последним изменениям ПМ

[REQ_PRJ_0004] Тестовый проект должен быть переносимым, т.е. легко импортируемым и запускаемым на сборку чужим пользователем

[REQ_PRJ_0005] Тестовый проект должен успешно собираться (без ошибок и предупреждений) с разными конфигурациями ПМ:

[REQ_PRJ_0006] OFF / FALSE / LOW / MIN и т.д.

[REQ_PRJ_0007] ON / TRUE / HIGH / MAX и т.д.

[REQ_PRJ_0008] промежуточные значения констант.

[REQ_PRJ_0009] Папки с результатами сборки (Debug/, Release/ и т.п.) не должны быть под контролем версий

[REQ_PRJ_0010] В тестовом проекте не должно быть неиспользуемых файлов

Примечание.

к требованию REQ_PRJ_0001:

Тестовый проект - это модульные тесты к ПМ и файл конфигурации проекта (в случае Eclipse - .cproject (.project), в случае CMake - СMakeList.txt и .cmake).

к требованию REQ_PRJ_0002:

сfg/ -- директория расположения конфигурационных заголовочных файлов и скрипта линкера. Имя скрипта линкера должно быть linker_cfg.ld. При необходимости внутри папки cfg/ могут быть созданы подпапки для хранения разных настроек одного и того же конфиг. файла.
dep/ -- директория расположения зависимостей ПМ (н-р, MCU драйвер, Error Tracer и пр.). Зависимость ПМ -- это то, без чего ПМ не соберется.
env/ -- директория расположения окружения ПМ (OS и прочие вспомогательные модули).
ide/ -- директория расположения конфигурационных файлов для инструментов сборки. Достаточно иметь лишь ту директорию, которая соответствует используемому инструменту.
tests/ -- директория расположения тестов к программному модулю.
к требованию REQ_PRJ_0003: внесение изменений в ПМ может повлечь изменение тестового проекта. Эти изменения должны соответствовать друг другу.

 

Приложение 1. Краткий словарь антонимов, общепринятых во встроенных системах реального времени
start – stop

get – set

suspend - resume

on – off

enable – disable

connect - disconnect

encode - decode

encrypt - decrypt

receive – transmit

read - write

add – remove

insert – delete

lock – unlock

open – close

init – deinit

show – hide

increment - decrement

minimum - maximum

old – new

first - last

up – down

left - right

next – previous

begin – end

slow - fast

source – destination

local – global

client – server

master – slave

active – passive

internal - external

request – response

input - output

не допускается использовать не соответствующие сочетания вроде "start – end"

Приложение 2. Краткий словарь аббревиатур, общепринятых во встроенных системах реального времени
ADC – Analog to Digital Converter

API – Application Programming Interface

CAN – Controller Area Network

DAC – Digital to Analog Converter

DMA – Direct Memory Access

ECU – Electronic Control Unit

I2C - Inter Integrated Circuit

LIN – Local Interconnect Network

MCU – MicroController Unit

MMU – Memory Management Unit

NMI – Non Maskable Interrupt

PLL – Phase Locked Loop

PWM – Pulse Width Modulation

RTOS – Real-Time Operating System

SFR – Special Function Register

SPI – Serial Peripheral Interface

UART – Universal Asynchronous Receiver/Transmitter

USART – Universal Synchronous-Asynchronous Receiver/Transmitter

Приложение 3. Краткий словарь сокращений, общепринятых во встроенных системах реального времени
addr – address

bin – binary

buf – buffer

cfg – configuration

circ - circular

cmd – command

cnt – counter

dec – decimal

dev – device

drv – driver

dst – destination

err – error

hex – hexadecimal

HW – hardware

ID – identifier

init – initialization

lng – length

max – maximum

min – minimum

msg – message

num – number

oct – octal

ptr – pointer

prev – previous

qty – quantity

RX – receive

src – source

srv – service

SW – software

TX – transmit

 

Примеры

[REQ_CODE_0419]

// Non-compliant
STD_RESULT result = RESULT_OK;
result = CIRCBUF_Init();

// Compliant
STD_RESULT result = CIRCBUF_Init();

[REQ_CODE_0425]

// Non-compliant
if (counter)

// Compliant
if (counter > 0)
Но допустимо, н-р

// Compliant
if (jobFinished)  
поскольку название переменной jobFinished отражает логические значения TRUE/FALSE.

[REQ_CODE_0432]

// Non-compliant

#define MY_TRUE     (1U)
#define MY_FALSE    (0U)

BOOLEAN flag = MY_TRUE;



// Compliant

#include "general.h"

BOOLEAN flag = TRUE;
[REQ_CODE_0433]

// Non-compliant

BOOLEAN isInited = ON;

U8 switchState = FALSE;



// Compliant

BOOLEAN isInited = TRUE;

U8 switchState = OFF;